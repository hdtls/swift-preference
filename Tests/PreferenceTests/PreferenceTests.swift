//
//  Preference.swift
//
//  Copyright (c) 2022 Junfeng Zhang
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

///
/// NOTE: This file was generated by gyb.py
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///

import Combine
import XCTest
@testable import Preference

extension String {
    static func random(_ length: Int = 16) -> String {
        String((0..<length).map { _ in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".randomElement()!
        })
    }
}

let store: UserDefaults = .init(suiteName: "swift-preference/\(UUID().uuidString)")!

extension UserDefaults.FieldKey {
    static let boolValue: UserDefaults.FieldKey = "BoolValue"
    static let optionalBoolValue: UserDefaults.FieldKey = "OptionalBoolValue"
    static let intValue: UserDefaults.FieldKey = "IntValue"
    static let optionalIntValue: UserDefaults.FieldKey = "OptionalIntValue"
    static let doubleValue: UserDefaults.FieldKey = "DoubleValue"
    static let optionalDoubleValue: UserDefaults.FieldKey = "OptionalDoubleValue"
    static let floatValue: UserDefaults.FieldKey = "FloatValue"
    static let optionalFloatValue: UserDefaults.FieldKey = "OptionalFloatValue"
    static let stringValue: UserDefaults.FieldKey = "StringValue"
    static let optionalStringValue: UserDefaults.FieldKey = "OptionalStringValue"
    static let urlValue: UserDefaults.FieldKey = "URLValue"
    static let optionalURLValue: UserDefaults.FieldKey = "OptionalURLValue"
    static let dataValue: UserDefaults.FieldKey = "DataValue"
    static let optionalDataValue: UserDefaults.FieldKey = "OptionalDataValue"
}

class PreferenceTests: XCTestCase {

    struct Preferences {
        @Preference(.boolValue, store: store) var boolValue: Bool = true
        @Preference(.optionalBoolValue, store: store) var optionalBoolValue: Bool?
        @Preference(.intValue, store: store) var intValue: Int = 5
        @Preference(.optionalIntValue, store: store) var optionalIntValue: Int?
        @Preference(.doubleValue, store: store) var doubleValue: Double = 0.07033802847862591
        @Preference(.optionalDoubleValue, store: store) var optionalDoubleValue: Double?
        @Preference(.floatValue, store: store) var floatValue: Float = 1.8874
        @Preference(.optionalFloatValue, store: store) var optionalFloatValue: Float?
        @Preference(.stringValue, store: store) var stringValue: String = "F1FOe4MS"
        @Preference(.optionalStringValue, store: store) var optionalStringValue: String?
        @Preference(.urlValue, store: store) var urlValue: URL = URL(string: "https://bY2ftCF4.com")!
        @Preference(.optionalURLValue, store: store) var optionalURLValue: URL?
        @Preference(.dataValue, store: store) var dataValue: Data = .init()
        @Preference(.optionalDataValue, store: store) var optionalDataValue: Data?
    }

    var preferences: Preferences = .init()
    var cancellable: Set<AnyCancellable> = .init()
    
    override func setUp() {
        // Put setup code here. This method is called before the invocation of each test method in the class.
        preferences = .init()
        cancellable.removeAll()
    }
        
    func testBoolValueReadWritePreference() {
        var boolValues: [Bool] = []
        var expectValues: [Bool] = [true]
        
        cancellable.insert(
            preferences.$boolValue.removeDuplicates().sink {
                boolValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.boolValue, true)

        var oldValue: Bool = true

        for _ in 0..<10 {
            let newValue = Bool.random()
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.boolValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.boolValue, newValue)
            XCTAssertEqual(store.bool(forKey: "BoolValue"), newValue)
        }

        for _ in 0..<10 {
            let newValue = Bool.random()
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "BoolValue")
            oldValue = newValue
            XCTAssertEqual(preferences.boolValue, newValue)
            XCTAssertEqual(store.bool(forKey: "BoolValue"), newValue)
        }

        XCTAssertEqual(boolValues, expectValues)
    }

    func testOptionalBoolValueReadWriteWithPreference() {
        var optionalBoolValues: [Bool?] = []
        var expectValues: [Bool?] = [nil]
        
        cancellable.insert(
            preferences.$optionalBoolValue.removeDuplicates().sink {
                optionalBoolValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalBoolValue)
        XCTAssertNil(store.object(forKey: "OptionalBoolValue"))

        var oldValue: Bool? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, Bool.random()]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalBoolValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalBoolValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalBoolValue"))
            } else {
                XCTAssertEqual(store.bool(forKey: "OptionalBoolValue"), newValue)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, Bool.random()]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalBoolValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalBoolValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalBoolValue"))
            } else {
                XCTAssertEqual(store.bool(forKey: "OptionalBoolValue"), newValue)
            }
        }

        XCTAssertEqual(optionalBoolValues, expectValues)
    }
        
    func testIntValueReadWritePreference() {
        var intValues: [Int] = []
        var expectValues: [Int] = [5]
        
        cancellable.insert(
            preferences.$intValue.removeDuplicates().sink {
                intValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.intValue, 5)

        var oldValue: Int = 5

        for _ in 0..<10 {
            let newValue = Int.random(in: 0...255)
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.intValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.intValue, newValue)
            XCTAssertEqual(store.integer(forKey: "IntValue"), newValue)
        }

        for _ in 0..<10 {
            let newValue = Int.random(in: 0...255)
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "IntValue")
            oldValue = newValue
            XCTAssertEqual(preferences.intValue, newValue)
            XCTAssertEqual(store.integer(forKey: "IntValue"), newValue)
        }

        XCTAssertEqual(intValues, expectValues)
    }

    func testOptionalIntValueReadWriteWithPreference() {
        var optionalIntValues: [Int?] = []
        var expectValues: [Int?] = [nil]
        
        cancellable.insert(
            preferences.$optionalIntValue.removeDuplicates().sink {
                optionalIntValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalIntValue)
        XCTAssertNil(store.object(forKey: "OptionalIntValue"))

        var oldValue: Int? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, Int.random(in: 0...255)]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalIntValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalIntValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalIntValue"))
            } else {
                XCTAssertEqual(store.integer(forKey: "OptionalIntValue"), newValue)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, Int.random(in: 0...255)]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalIntValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalIntValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalIntValue"))
            } else {
                XCTAssertEqual(store.integer(forKey: "OptionalIntValue"), newValue)
            }
        }

        XCTAssertEqual(optionalIntValues, expectValues)
    }
        
    func testDoubleValueReadWritePreference() {
        var doubleValues: [Double] = []
        var expectValues: [Double] = [0.07033802847862591]
        
        cancellable.insert(
            preferences.$doubleValue.removeDuplicates().sink {
                doubleValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.doubleValue, 0.07033802847862591)

        var oldValue: Double = 0.07033802847862591

        for _ in 0..<10 {
            let newValue = Double.random(in: 0...255)
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.doubleValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.doubleValue, newValue)
            XCTAssertEqual(store.double(forKey: "DoubleValue"), newValue)
        }

        for _ in 0..<10 {
            let newValue = Double.random(in: 0...255)
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "DoubleValue")
            oldValue = newValue
            XCTAssertEqual(preferences.doubleValue, newValue)
            XCTAssertEqual(store.double(forKey: "DoubleValue"), newValue)
        }

        XCTAssertEqual(doubleValues, expectValues)
    }

    func testOptionalDoubleValueReadWriteWithPreference() {
        var optionalDoubleValues: [Double?] = []
        var expectValues: [Double?] = [nil]
        
        cancellable.insert(
            preferences.$optionalDoubleValue.removeDuplicates().sink {
                optionalDoubleValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalDoubleValue)
        XCTAssertNil(store.object(forKey: "OptionalDoubleValue"))

        var oldValue: Double? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, Double.random(in: 0...255)]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalDoubleValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalDoubleValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalDoubleValue"))
            } else {
                XCTAssertEqual(store.double(forKey: "OptionalDoubleValue"), newValue)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, Double.random(in: 0...255)]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalDoubleValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalDoubleValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalDoubleValue"))
            } else {
                XCTAssertEqual(store.double(forKey: "OptionalDoubleValue"), newValue)
            }
        }

        XCTAssertEqual(optionalDoubleValues, expectValues)
    }
        
    func testFloatValueReadWritePreference() {
        var floatValues: [Float] = []
        var expectValues: [Float] = [1.8874]
        
        cancellable.insert(
            preferences.$floatValue.removeDuplicates().sink {
                floatValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.floatValue, 1.8874)

        var oldValue: Float = 1.8874

        for _ in 0..<10 {
            let newValue = Float.random(in: 0...255)
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.floatValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.floatValue, newValue)
            XCTAssertEqual(store.float(forKey: "FloatValue"), newValue)
        }

        for _ in 0..<10 {
            let newValue = Float.random(in: 0...255)
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "FloatValue")
            oldValue = newValue
            XCTAssertEqual(preferences.floatValue, newValue)
            XCTAssertEqual(store.float(forKey: "FloatValue"), newValue)
        }

        XCTAssertEqual(floatValues, expectValues)
    }

    func testOptionalFloatValueReadWriteWithPreference() {
        var optionalFloatValues: [Float?] = []
        var expectValues: [Float?] = [nil]
        
        cancellable.insert(
            preferences.$optionalFloatValue.removeDuplicates().sink {
                optionalFloatValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalFloatValue)
        XCTAssertNil(store.object(forKey: "OptionalFloatValue"))

        var oldValue: Float? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, Float.random(in: 0...255)]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalFloatValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalFloatValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalFloatValue"))
            } else {
                XCTAssertEqual(store.float(forKey: "OptionalFloatValue"), newValue)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, Float.random(in: 0...255)]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalFloatValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalFloatValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalFloatValue"))
            } else {
                XCTAssertEqual(store.float(forKey: "OptionalFloatValue"), newValue)
            }
        }

        XCTAssertEqual(optionalFloatValues, expectValues)
    }
        
    func testStringValueReadWritePreference() {
        var stringValues: [String] = []
        var expectValues: [String] = ["F1FOe4MS"]
        
        cancellable.insert(
            preferences.$stringValue.removeDuplicates().sink {
                stringValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.stringValue, "F1FOe4MS")

        var oldValue: String = "F1FOe4MS"

        for _ in 0..<10 {
            let newValue = String.random()
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.stringValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.stringValue, newValue)
            XCTAssertEqual(store.string(forKey: "StringValue"), newValue)
        }

        for _ in 0..<10 {
            let newValue = String.random()
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "StringValue")
            oldValue = newValue
            XCTAssertEqual(preferences.stringValue, newValue)
            XCTAssertEqual(store.string(forKey: "StringValue"), newValue)
        }

        XCTAssertEqual(stringValues, expectValues)
    }

    func testOptionalStringValueReadWriteWithPreference() {
        var optionalStringValues: [String?] = []
        var expectValues: [String?] = [nil]
        
        cancellable.insert(
            preferences.$optionalStringValue.removeDuplicates().sink {
                optionalStringValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalStringValue)
        XCTAssertNil(store.object(forKey: "OptionalStringValue"))

        var oldValue: String? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, String.random()]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalStringValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalStringValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalStringValue"))
            } else {
                XCTAssertEqual(store.string(forKey: "OptionalStringValue"), newValue)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, String.random()]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalStringValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalStringValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalStringValue"))
            } else {
                XCTAssertEqual(store.string(forKey: "OptionalStringValue"), newValue)
            }
        }

        XCTAssertEqual(optionalStringValues, expectValues)
    }
        
    func testURLValueReadWritePreference() {
        var urlValues: [URL] = []
        var expectValues: [URL] = [URL(string: "https://bY2ftCF4.com")!]
        
        cancellable.insert(
            preferences.$urlValue.removeDuplicates().sink {
                urlValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.urlValue, URL(string: "https://bY2ftCF4.com")!)

        var oldValue: URL = URL(string: "https://bY2ftCF4.com")!

        for _ in 0..<10 {
            let newValue = URL(string: "https://" + .random() + ".com")!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.urlValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.urlValue, newValue)
            XCTAssertEqual(store.url(forKey: "URLValue")?.absoluteURL.path, newValue.absoluteURL.path)
        }

        for _ in 0..<10 {
            let newValue = URL(string: "https://" + .random() + ".com")!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "URLValue")
            oldValue = newValue
            XCTAssertEqual(preferences.urlValue, newValue)
            XCTAssertEqual(store.url(forKey: "URLValue")?.absoluteURL.path, newValue.absoluteURL.path)
        }

        XCTAssertEqual(urlValues, expectValues)
    }

    func testOptionalURLValueReadWriteWithPreference() {
        var optionalURLValues: [URL?] = []
        var expectValues: [URL?] = [nil]
        
        cancellable.insert(
            preferences.$optionalURLValue.removeDuplicates().sink {
                optionalURLValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalURLValue)
        XCTAssertNil(store.object(forKey: "OptionalURLValue"))

        var oldValue: URL? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, URL(string: "https://" + .random() + ".com")]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalURLValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalURLValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalURLValue"))
            } else {
                XCTAssertEqual(store.url(forKey: "OptionalURLValue")?.absoluteURL.path, newValue?.absoluteURL.path)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, URL(string: "https://" + .random() + ".com")]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalURLValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalURLValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalURLValue"))
            } else {
                XCTAssertEqual(store.url(forKey: "OptionalURLValue")?.absoluteURL.path, newValue?.absoluteURL.path)
            }
        }

        XCTAssertEqual(optionalURLValues, expectValues)
    }
        
    func testDataValueReadWritePreference() {
        var dataValues: [Data] = []
        var expectValues: [Data] = [.init()]
        
        cancellable.insert(
            preferences.$dataValue.removeDuplicates().sink {
                dataValues.append($0)
            }
        )
        
        XCTAssertEqual(preferences.dataValue, .init())

        var oldValue: Data = .init()

        for _ in 0..<10 {
            let newValue = Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max)})
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.dataValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.dataValue, newValue)
            XCTAssertEqual(store.data(forKey: "DataValue"), newValue)
        }

        for _ in 0..<10 {
            let newValue = Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max)})
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "DataValue")
            oldValue = newValue
            XCTAssertEqual(preferences.dataValue, newValue)
            XCTAssertEqual(store.data(forKey: "DataValue"), newValue)
        }

        XCTAssertEqual(dataValues, expectValues)
    }

    func testOptionalDataValueReadWriteWithPreference() {
        var optionalDataValues: [Data?] = []
        var expectValues: [Data?] = [nil]
        
        cancellable.insert(
            preferences.$optionalDataValue.removeDuplicates().sink {
                optionalDataValues.append($0)
            }
        )
        
        XCTAssertNil(preferences.optionalDataValue)
        XCTAssertNil(store.object(forKey: "OptionalDataValue"))

        var oldValue: Data? = nil

        for _ in 0..<10 {
            let allowedValues = [nil, Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max)})]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optionalDataValue = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optionalDataValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalDataValue"))
            } else {
                XCTAssertEqual(store.data(forKey: "OptionalDataValue"), newValue)
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max)})]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "OptionalDataValue")
            oldValue = newValue
            XCTAssertEqual(preferences.optionalDataValue, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "OptionalDataValue"))
            } else {
                XCTAssertEqual(store.data(forKey: "OptionalDataValue"), newValue)
            }
        }

        XCTAssertEqual(optionalDataValues, expectValues)
    }
}
