//
// MIT License
//
// Copyright (c) 2022 Junfeng Zhang and the Preference project authors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

///
/// NOTE: This file was generated by gyb.py
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///

import XCTest

@testable import Preference

extension String {
  static func random(_ length: Int = 16) -> String {
    String(
      (0..<length).map { _ in
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".randomElement()!
      }
    )
  }
}

let store: UserDefaults = .init(suiteName: "swift-preference/\(UUID().uuidString)")!

// swift-format-ignore: DontRepeatTypeInStaticProperties
extension String {
  static let boolValue = "BoolValue"
  static let optionalBoolValue = "OptionalBoolValue"
  static let intValue = "IntValue"
  static let optionalIntValue = "OptionalIntValue"
  static let doubleValue = "DoubleValue"
  static let optionalDoubleValue = "OptionalDoubleValue"
  static let floatValue = "FloatValue"
  static let optionalFloatValue = "OptionalFloatValue"
  static let stringValue = "StringValue"
  static let optionalStringValue = "OptionalStringValue"
  static let urlValue = "URLValue"
  static let optionalURLValue = "OptionalURLValue"
  static let dataValue = "DataValue"
  static let optionalDataValue = "OptionalDataValue"
  static let dateValue = "DateValue"
  static let optionalDateValue = "OptionalDateValue"
}

class PreferenceTests: XCTestCase {

  struct Preferences {
    @Preference(.boolValue, store: store) var boolValue: Bool = true
    @Preference(.optionalBoolValue, store: store) var optionalBoolValue: Bool?
    @Preference(.intValue, store: store) var intValue: Int = 9
    @Preference(.optionalIntValue, store: store) var optionalIntValue: Int?
    @Preference(.doubleValue, store: store) var doubleValue: Double = 0.963478609704102
    @Preference(.optionalDoubleValue, store: store) var optionalDoubleValue: Double?
    @Preference(.floatValue, store: store) var floatValue: Float = 1.9783
    @Preference(.optionalFloatValue, store: store) var optionalFloatValue: Float?
    @Preference(.stringValue, store: store) var stringValue: String = "tjQcBeXY"
    @Preference(.optionalStringValue, store: store) var optionalStringValue: String?
    @Preference(.urlValue, store: store) var urlValue: URL = URL(string: "https://KiLev3hf.com")!
    @Preference(.optionalURLValue, store: store) var optionalURLValue: URL?
    @Preference(.dataValue, store: store) var dataValue: Data = .init()
    @Preference(.optionalDataValue, store: store) var optionalDataValue: Data?
    @Preference(.dateValue, store: store) var dateValue: Date = .distantPast
    @Preference(.optionalDateValue, store: store) var optionalDateValue: Date?
  }

  var preferences: Preferences = .init()
  var cancellable: Set<AnyCancellable> = .init()

  override func setUp() {
    // Put setup code here. This method is called before the invocation of each test method in the class.
    preferences = .init()
    cancellable.removeAll()
  }

  func testReadWriteBoolValueWithPreference() {
    var boolValues: [Bool] = []
    var expectValues: [Bool] = [true]

    cancellable.insert(
      preferences.$boolValue.sink {
        boolValues.append($0)
      }
    )

    XCTAssertEqual(preferences.boolValue, true)

    var oldValue: Bool = true

    for _ in 0..<10 {
      let newValue = Bool.random()
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.boolValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.boolValue, newValue)
      XCTAssertEqual(store.bool(forKey: "BoolValue"), newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = Bool.random()
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "BoolValue")
        oldValue = newValue
        XCTAssertEqual(preferences.boolValue, newValue)
        XCTAssertEqual(store.bool(forKey: "BoolValue"), newValue)
      }
    #endif

    XCTAssertEqual(boolValues, expectValues)
  }

  func testReadWriteOptionalBoolValueWithPreference() {
    var optionalBoolValues: [Bool?] = []
    var expectValues: [Bool?] = [nil]

    cancellable.insert(
      preferences.$optionalBoolValue.sink {
        optionalBoolValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalBoolValue)
    XCTAssertNil(store.object(forKey: "OptionalBoolValue"))

    var oldValue: Bool? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, Bool.random()]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalBoolValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalBoolValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.bool(forKey: "OptionalBoolValue"), false)
      } else {
        XCTAssertEqual(store.bool(forKey: "OptionalBoolValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, Bool.random()]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalBoolValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalBoolValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.bool(forKey: "OptionalBoolValue"), false)
        } else {
          XCTAssertEqual(store.bool(forKey: "OptionalBoolValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalBoolValues, expectValues)
  }

  func testReadWriteIntValueWithPreference() {
    var intValues: [Int] = []
    var expectValues: [Int] = [9]

    cancellable.insert(
      preferences.$intValue.sink {
        intValues.append($0)
      }
    )

    XCTAssertEqual(preferences.intValue, 9)

    var oldValue: Int = 9

    for _ in 0..<10 {
      let newValue = Int.random(in: 0...255)
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.intValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.intValue, newValue)
      XCTAssertEqual(store.integer(forKey: "IntValue"), newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = Int.random(in: 0...255)
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "IntValue")
        oldValue = newValue
        XCTAssertEqual(preferences.intValue, newValue)
        XCTAssertEqual(store.integer(forKey: "IntValue"), newValue)
      }
    #endif

    XCTAssertEqual(intValues, expectValues)
  }

  func testReadWriteOptionalIntValueWithPreference() {
    var optionalIntValues: [Int?] = []
    var expectValues: [Int?] = [nil]

    cancellable.insert(
      preferences.$optionalIntValue.sink {
        optionalIntValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalIntValue)
    XCTAssertNil(store.object(forKey: "OptionalIntValue"))

    var oldValue: Int? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, Int.random(in: 0...255)]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalIntValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalIntValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.integer(forKey: "OptionalIntValue"), 0)
      } else {
        XCTAssertEqual(store.integer(forKey: "OptionalIntValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, Int.random(in: 0...255)]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalIntValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalIntValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.integer(forKey: "OptionalIntValue"), 0)
        } else {
          XCTAssertEqual(store.integer(forKey: "OptionalIntValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalIntValues, expectValues)
  }

  func testReadWriteDoubleValueWithPreference() {
    var doubleValues: [Double] = []
    var expectValues: [Double] = [0.963478609704102]

    cancellable.insert(
      preferences.$doubleValue.sink {
        doubleValues.append($0)
      }
    )

    XCTAssertEqual(preferences.doubleValue, 0.963478609704102)

    var oldValue: Double = 0.963478609704102

    for _ in 0..<10 {
      let newValue = Double.random(in: 0...255)
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.doubleValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.doubleValue, newValue)
      XCTAssertEqual(store.double(forKey: "DoubleValue"), newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = Double.random(in: 0...255)
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "DoubleValue")
        oldValue = newValue
        XCTAssertEqual(preferences.doubleValue, newValue)
        XCTAssertEqual(store.double(forKey: "DoubleValue"), newValue)
      }
    #endif

    XCTAssertEqual(doubleValues, expectValues)
  }

  func testReadWriteOptionalDoubleValueWithPreference() {
    var optionalDoubleValues: [Double?] = []
    var expectValues: [Double?] = [nil]

    cancellable.insert(
      preferences.$optionalDoubleValue.sink {
        optionalDoubleValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalDoubleValue)
    XCTAssertNil(store.object(forKey: "OptionalDoubleValue"))

    var oldValue: Double? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, Double.random(in: 0...255)]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalDoubleValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalDoubleValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.double(forKey: "OptionalDoubleValue"), 0.0)
      } else {
        XCTAssertEqual(store.double(forKey: "OptionalDoubleValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, Double.random(in: 0...255)]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalDoubleValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalDoubleValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.double(forKey: "OptionalDoubleValue"), 0.0)
        } else {
          XCTAssertEqual(store.double(forKey: "OptionalDoubleValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalDoubleValues, expectValues)
  }

  func testReadWriteFloatValueWithPreference() {
    var floatValues: [Float] = []
    var expectValues: [Float] = [1.9783]

    cancellable.insert(
      preferences.$floatValue.sink {
        floatValues.append($0)
      }
    )

    XCTAssertEqual(preferences.floatValue, 1.9783)

    var oldValue: Float = 1.9783

    for _ in 0..<10 {
      let newValue = Float.random(in: 0...255)
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.floatValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.floatValue, newValue)
      XCTAssertEqual(store.float(forKey: "FloatValue"), newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = Float.random(in: 0...255)
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "FloatValue")
        oldValue = newValue
        XCTAssertEqual(preferences.floatValue, newValue)
        XCTAssertEqual(store.float(forKey: "FloatValue"), newValue)
      }
    #endif

    XCTAssertEqual(floatValues, expectValues)
  }

  func testReadWriteOptionalFloatValueWithPreference() {
    var optionalFloatValues: [Float?] = []
    var expectValues: [Float?] = [nil]

    cancellable.insert(
      preferences.$optionalFloatValue.sink {
        optionalFloatValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalFloatValue)
    XCTAssertNil(store.object(forKey: "OptionalFloatValue"))

    var oldValue: Float? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, Float.random(in: 0...255)]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalFloatValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalFloatValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.float(forKey: "OptionalFloatValue"), 0.0)
      } else {
        XCTAssertEqual(store.float(forKey: "OptionalFloatValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, Float.random(in: 0...255)]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalFloatValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalFloatValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.float(forKey: "OptionalFloatValue"), 0.0)
        } else {
          XCTAssertEqual(store.float(forKey: "OptionalFloatValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalFloatValues, expectValues)
  }

  func testReadWriteStringValueWithPreference() {
    var stringValues: [String] = []
    var expectValues: [String] = ["tjQcBeXY"]

    cancellable.insert(
      preferences.$stringValue.sink {
        stringValues.append($0)
      }
    )

    XCTAssertEqual(preferences.stringValue, "tjQcBeXY")

    var oldValue: String = "tjQcBeXY"

    for _ in 0..<10 {
      let newValue = String.random()
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.stringValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.stringValue, newValue)
      XCTAssertEqual(store.string(forKey: "StringValue"), newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = String.random()
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "StringValue")
        oldValue = newValue
        XCTAssertEqual(preferences.stringValue, newValue)
        XCTAssertEqual(store.string(forKey: "StringValue"), newValue)
      }
    #endif

    XCTAssertEqual(stringValues, expectValues)
  }

  func testReadWriteOptionalStringValueWithPreference() {
    var optionalStringValues: [String?] = []
    var expectValues: [String?] = [nil]

    cancellable.insert(
      preferences.$optionalStringValue.sink {
        optionalStringValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalStringValue)
    XCTAssertNil(store.object(forKey: "OptionalStringValue"))

    var oldValue: String? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, String.random()]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalStringValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalStringValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.string(forKey: "OptionalStringValue"), nil)
      } else {
        XCTAssertEqual(store.string(forKey: "OptionalStringValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, String.random()]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalStringValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalStringValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.string(forKey: "OptionalStringValue"), nil)
        } else {
          XCTAssertEqual(store.string(forKey: "OptionalStringValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalStringValues, expectValues)
  }

  func testReadWriteURLValueWithPreference() {
    var urlValues: [URL] = []
    var expectValues: [URL] = [URL(string: "https://KiLev3hf.com")!]

    cancellable.insert(
      preferences.$urlValue.sink {
        urlValues.append($0)
      }
    )

    XCTAssertEqual(preferences.urlValue, URL(string: "https://KiLev3hf.com")!)

    var oldValue: URL = URL(string: "https://KiLev3hf.com")!

    for _ in 0..<10 {
      let newValue = URL(string: "https://" + .random() + ".com")!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.urlValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.urlValue, newValue)
      XCTAssertEqual(store.url(forKey: "URLValue")?.absoluteURL.path, newValue.absoluteURL.path)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = URL(string: "https://" + .random() + ".com")!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "URLValue")
        oldValue = newValue
        XCTAssertEqual(preferences.urlValue, newValue)
        XCTAssertEqual(store.url(forKey: "URLValue")?.absoluteURL.path, newValue.absoluteURL.path)
      }
    #endif

    XCTAssertEqual(urlValues, expectValues)
  }

  func testReadWriteOptionalURLValueWithPreference() {
    var optionalURLValues: [URL?] = []
    var expectValues: [URL?] = [nil]

    cancellable.insert(
      preferences.$optionalURLValue.sink {
        optionalURLValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalURLValue)
    XCTAssertNil(store.object(forKey: "OptionalURLValue"))

    var oldValue: URL? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, URL(string: "https://" + .random() + ".com")]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalURLValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalURLValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.url(forKey: "OptionalURLValue"), nil)
      } else {
        XCTAssertEqual(store.url(forKey: "OptionalURLValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, URL(string: "https://" + .random() + ".com")]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalURLValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalURLValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.url(forKey: "OptionalURLValue"), nil)
        } else {
          XCTAssertEqual(store.url(forKey: "OptionalURLValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalURLValues, expectValues)
  }

  func testReadWriteDataValueWithPreference() {
    var dataValues: [Data] = []
    var expectValues: [Data] = [.init()]

    cancellable.insert(
      preferences.$dataValue.sink {
        dataValues.append($0)
      }
    )

    XCTAssertEqual(preferences.dataValue, .init())

    var oldValue: Data = .init()

    for _ in 0..<10 {
      let newValue = Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max) })
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.dataValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.dataValue, newValue)
      XCTAssertEqual(store.data(forKey: "DataValue"), newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max) })
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "DataValue")
        oldValue = newValue
        XCTAssertEqual(preferences.dataValue, newValue)
        XCTAssertEqual(store.data(forKey: "DataValue"), newValue)
      }
    #endif

    XCTAssertEqual(dataValues, expectValues)
  }

  func testReadWriteOptionalDataValueWithPreference() {
    var optionalDataValues: [Data?] = []
    var expectValues: [Data?] = [nil]

    cancellable.insert(
      preferences.$optionalDataValue.sink {
        optionalDataValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalDataValue)
    XCTAssertNil(store.object(forKey: "OptionalDataValue"))

    var oldValue: Data? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max) })]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalDataValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalDataValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.data(forKey: "OptionalDataValue"), nil)
      } else {
        XCTAssertEqual(store.data(forKey: "OptionalDataValue"), newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max) })]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalDataValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalDataValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.data(forKey: "OptionalDataValue"), nil)
        } else {
          XCTAssertEqual(store.data(forKey: "OptionalDataValue"), newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalDataValues, expectValues)
  }

  func testReadWriteDateValueWithPreference() {
    var dateValues: [Date] = []
    var expectValues: [Date] = [.distantPast]

    cancellable.insert(
      preferences.$dateValue.sink {
        dateValues.append($0)
      }
    )

    XCTAssertEqual(preferences.dateValue, .distantPast)

    var oldValue: Date = .distantPast

    for _ in 0..<10 {
      let newValue = Date.distantPast
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.dateValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.dateValue, newValue)
      XCTAssertEqual(store.object(forKey: "DateValue") as? Date, newValue)
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let newValue = Date.distantPast
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "DateValue")
        oldValue = newValue
        XCTAssertEqual(preferences.dateValue, newValue)
        XCTAssertEqual(store.object(forKey: "DateValue") as? Date, newValue)
      }
    #endif

    XCTAssertEqual(dateValues, expectValues)
  }

  func testReadWriteOptionalDateValueWithPreference() {
    var optionalDateValues: [Date?] = []
    var expectValues: [Date?] = [nil]

    cancellable.insert(
      preferences.$optionalDateValue.sink {
        optionalDateValues.append($0)
      }
    )

    XCTAssertNil(preferences.optionalDateValue)
    XCTAssertNil(store.object(forKey: "OptionalDateValue"))

    var oldValue: Date? = nil

    for _ in 0..<10 {
      let allowedValues = [nil, Date.distantPast]
      let newValue = allowedValues.randomElement()!
      if newValue != oldValue {
        expectValues.append(newValue)
      }
      preferences.optionalDateValue = newValue
      oldValue = newValue
      XCTAssertEqual(preferences.optionalDateValue, newValue)
      if newValue == nil {
        XCTAssertEqual(store.object(forKey: "OptionalDateValue") as? Date, nil)
      } else {
        XCTAssertEqual(store.object(forKey: "OptionalDateValue") as? Date, newValue)
      }
    }

    #if canImport(Darwin)
      for _ in 0..<10 {
        let allowedValues = [nil, Date.distantPast]
        let newValue = allowedValues.randomElement()!
        if newValue != oldValue {
          expectValues.append(newValue)
        }
        store.set(newValue, forKey: "OptionalDateValue")
        oldValue = newValue
        XCTAssertEqual(preferences.optionalDateValue, newValue)
        if newValue == nil {
          XCTAssertEqual(store.object(forKey: "OptionalDateValue") as? Date, nil)
        } else {
          XCTAssertEqual(store.object(forKey: "OptionalDateValue") as? Date, newValue)
        }
      }
    #endif

    XCTAssertEqual(optionalDateValues, expectValues)
  }
}
