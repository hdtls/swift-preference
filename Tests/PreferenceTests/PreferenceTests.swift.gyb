//
//  Preference.swift
//
//  Copyright (c) 2022 Junfeng Zhang
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

///
/// NOTE: This file was generated by gyb.py
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///

import Combine
import XCTest
@testable import Preference
%{
import string
import random

preference_testable_defines = {
    "Bool": {
        "selector": "bool",
        "initialValue": "true"
    },
    "Int": {
        "selector": "integer",
        "initialValue": random.choice(string.digits)
    },
    "Double": {
        "selector": "double",
        "initialValue": "{}".format(random.random())
    },
    "Float": {
        "selector": "float",
        "initialValue": "{}".format(round(random.uniform(1,2), 4))
    },
    "String": {
        "selector": "string",
        "initialValue": '"{}"'.format(''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits) for _ in range(8)))
    },
    "URL": {
        "selector": "url",
        "initialValue": 'URL(string: "https://{}.com")!'.format(''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits) for _ in range(8)))
    },
    "Data": {
        "selector": "data",
        "initialValue": ".init()"
    }
}
}%

extension String {
    static func random(_ length: Int = 16) -> String {
        String((0..<length).map { _ in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".randomElement()!
        })
    }
}

let store: UserDefaults = .init(suiteName: "swift-preference/\(UUID().uuidString)")!

extension UserDefaults.FieldKey {
    %for define in preference_testable_defines.keys():
    static let ${define.lower()}Value: UserDefaults.FieldKey = "${define}Value"
    static let optional${define}Value: UserDefaults.FieldKey = "Optional${define}Value"
    %end
}

class PreferenceTests: XCTestCase {

    struct Preferences {
        %for define in preference_testable_defines.keys():
        @Preference(.${define.lower()}Value, store: store) var ${define.lower()}Value: ${define} = ${preference_testable_defines[define]["initialValue"]}
        @Preference(.optional${define}Value, store: store) var optional${define}Value: ${define}?
        %end
    }

    var preferences: Preferences = .init()
    var cancellable: Set<AnyCancellable> = .init()
    
    override func setUp() {
        // Put setup code here. This method is called before the invocation of each test method in the class.
        preferences = .init()
        cancellable.removeAll()
    }
    %for define in preference_testable_defines.keys():
        
    func test${define}ValueReadWritePreference() {
        var ${define.lower()}Values: [${define}] = []
        var expectValues: [${define}] = [${preference_testable_defines[define]["initialValue"]}]
        
        cancellable.insert(
            preferences.$$${define.lower()}Value.removeDuplicates().sink {
                ${define.lower()}Values.append($0)
            }
        )
        
        XCTAssertEqual(preferences.${define.lower()}Value, ${preference_testable_defines[define]["initialValue"]})

        var oldValue: ${define} = ${preference_testable_defines[define]["initialValue"]}

        %{
        if define == "Bool":
            val = define + ".random()"
        elif define in ["Int", "Double", "Float"]:
            val = define + ".random(in: 0...255)"
        elif define == "String":
                val = define + ".random()"
        elif define == "URL":
                val = "URL(string: \"https://\" + .random() + \".com\")!"
        elif define == "Data":
            val = "Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max)})"
        else:
            val = "nil"
        }%
        for _ in 0..<10 {
            let newValue = ${val}
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.${define.lower()}Value = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.${define.lower()}Value, newValue)
            %{
            if define == "URL":
                lhs = 'store.{}(forKey: "{}Value")?.absoluteURL.path'.format(preference_testable_defines[define]["selector"], define)
                rhs = "newValue.absoluteURL.path"
            else:
                lhs = 'store.{}(forKey: "{}Value")'.format(preference_testable_defines[define]["selector"], define)
                rhs = "newValue"
            }%
            XCTAssertEqual(${lhs}, ${rhs})
        }

        for _ in 0..<10 {
            let newValue = ${val}
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "${define}Value")
            oldValue = newValue
            XCTAssertEqual(preferences.${define.lower()}Value, newValue)
            %{
            if define == "URL":
                lhs = 'store.{}(forKey: "{}Value")?.absoluteURL.path'.format(preference_testable_defines[define]["selector"], define)
                rhs = "newValue.absoluteURL.path"
            else:
                lhs = 'store.{}(forKey: "{}Value")'.format(preference_testable_defines[define]["selector"], define)
                rhs = "newValue"
            }%
            XCTAssertEqual(${lhs}, ${rhs})
        }

        XCTAssertEqual(${define.lower()}Values, expectValues)
    }

    func testOptional${define}ValueReadWriteWithPreference() {
        var optional${define}Values: [${define}?] = []
        var expectValues: [${define}?] = [nil]
        
        cancellable.insert(
            preferences.$optional${define}Value.removeDuplicates().sink {
                optional${define}Values.append($0)
            }
        )
        
        XCTAssertNil(preferences.optional${define}Value)
        XCTAssertNil(store.object(forKey: "Optional${define}Value"))

        var oldValue: ${define}? = nil

        %{
        if define == "Bool":
            val = define + ".random()"
        elif define in ["Int", "Double", "Float"]:
            val = define + ".random(in: 0...255)"
        elif define == "String":
            val = define + ".random()"
        elif define == "URL":
            val = "URL(string: \"https://\" + .random() + \".com\")"
        elif define == "Data":
            val = "Data((0...10).map { _ in UInt8.random(in: .min...UInt8.max)})"
        else:
            val = "nil"
        }%
        for _ in 0..<10 {
            let allowedValues = [nil, ${val}]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            preferences.optional${define}Value = newValue
            oldValue = newValue
            XCTAssertEqual(preferences.optional${define}Value, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "Optional${define}Value"))
            } else {
                %{
                if define == "URL":
                    lhs = 'store.{}(forKey: "Optional{}Value")?.absoluteURL.path'.format(preference_testable_defines[define]["selector"], define)
                    rhs = "newValue?.absoluteURL.path"
                else:
                    lhs = 'store.{}(forKey: "Optional{}Value")'.format(preference_testable_defines[define]["selector"], define)
                    rhs = "newValue"
                }%
                XCTAssertEqual(${lhs}, ${rhs})
            }
        }

        for _ in 0..<10 {
            let allowedValues = [nil, ${val}]
            let newValue = allowedValues.randomElement()!
            if newValue != oldValue {
                expectValues.append(newValue)
            }
            store.set(newValue, forKey: "Optional${define}Value")
            oldValue = newValue
            XCTAssertEqual(preferences.optional${define}Value, newValue)
            if newValue == nil {
                XCTAssertNil(store.object(forKey: "Optional${define}Value"))
            } else {
                %{
                if define == "URL":
                    lhs = 'store.{}(forKey: "Optional{}Value")?.absoluteURL.path'.format(preference_testable_defines[define]["selector"], define)
                    rhs = "newValue?.absoluteURL.path"
                else:
                    lhs = 'store.{}(forKey: "Optional{}Value")'.format(preference_testable_defines[define]["selector"], define)
                    rhs = "newValue"
                }%
                XCTAssertEqual(${lhs}, ${rhs})
            }
        }

        XCTAssertEqual(optional${define}Values, expectValues)
    }
    %end
}
